#lang racket

(require math/matrix)

(provide cinematica-direta)

(define (matDH a alpha1 d teta1)
  (let ( (alpha (/ (* pi alpha1) 180))
         (teta  (/ (* pi teta1) 180)) )
    (let ( (a11 (cos teta))
           (a12 (- (* (sin teta) (cos alpha))))
           (a13 (* (sin teta) (sin alpha)))
           (a14 (* a (cos teta)))
           (a21 (sin teta))
           (a22 (* (cos teta) (cos alpha)))
           (a23 (- (* (cos teta) (sin alpha))))
           (a24 (* a (sin teta)))
           (a31 0)
           (a32 (sin alpha))
           (a33 (cos alpha))
           (a34 d)
           (a41 0)
           (a42 0)
           (a43 0)
           (a44 1) )
      (list->matrix 4 4 (list a11 a12 a13 a14
                              a21 a22 a23 a24
                              a31 a32 a33 a34
                              a41 a42 a43 a44)) ) ) )

(define (cinematica-direta teta1 teta2 teta3)
  (let ( (teta11 (+ 90 teta1))
         (teta22 (- teta2))
         (teta33 teta3) )
    (dCinematica teta11 teta22 teta33) ))

(define (dCinematica teta1 teta2 teta3)
  (let  ((d1 9.00)
         (l1 10.55)
         (l2 14.45)
         (a1 4.00)
         (a2 2.90)
         (ly 0.70))
    (let ( (alpha1 -90) )
      (let ( (matDH1 (matDH ly alpha1 d1 teta1))
             (matDH2 (matDH l1 0 (+ a1 a2) teta2))
             (matDH3 (matDH l2 0 0 teta3)) )
        (let* ( (m1 (matrix* matDH1 matDH2))
                (T  (matrix* m1 matDH3)) )
          (pegarPosicao T)) )) ))

(define (pegarPosicao T)
  (let ( (x (matrix-ref T 0 3))
         (y (matrix-ref T 1 3))
         (z (matrix-ref T 2 3)) )
    (displayln (~a "x: " x))
    (displayln (~a "y: " y))
    (displayln (~a "z: " z))) )